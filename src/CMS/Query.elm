-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module CMS.Query exposing (AssetRequiredArguments, AssetsConnectionOptionalArguments, AssetsOptionalArguments, CallToActionRequiredArguments, CallToActionsConnectionOptionalArguments, CallToActionsOptionalArguments, ColorRequiredArguments, ColorsConnectionOptionalArguments, ColorsOptionalArguments, ExplanationBlockRequiredArguments, ExplanationBlocksConnectionOptionalArguments, ExplanationBlocksOptionalArguments, FaqRequiredArguments, FaqsConnectionOptionalArguments, FaqsOptionalArguments, LocationRequiredArguments, LocationsConnectionOptionalArguments, LocationsOptionalArguments, NodeRequiredArguments, PageRequiredArguments, PagesConnectionOptionalArguments, PagesOptionalArguments, asset, assets, assetsConnection, callToAction, callToActions, callToActionsConnection, color, colors, colorsConnection, explanationBlock, explanationBlocks, explanationBlocksConnection, faq, faqs, faqsConnection, location, locations, locationsConnection, node, page, pages, pagesConnection)

import CMS.Enum.AssetOrderByInput
import CMS.Enum.CallToActionOrderByInput
import CMS.Enum.ColorOrderByInput
import CMS.Enum.ExplanationBlockOrderByInput
import CMS.Enum.FaqOrderByInput
import CMS.Enum.LocationOrderByInput
import CMS.Enum.PageOrderByInput
import CMS.InputObject
import CMS.Interface
import CMS.Object
import CMS.Scalar
import CMS.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias AssetsOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.AssetWhereInput
    , orderBy : OptionalArgument CMS.Enum.AssetOrderByInput.AssetOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
assets : (AssetsOptionalArguments -> AssetsOptionalArguments) -> SelectionSet decodesTo CMS.Object.Asset -> SelectionSet (List (Maybe decodesTo)) RootQuery
assets fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeAssetWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.AssetOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "assets" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias ColorsOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.ColorWhereInput
    , orderBy : OptionalArgument CMS.Enum.ColorOrderByInput.ColorOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
colors : (ColorsOptionalArguments -> ColorsOptionalArguments) -> SelectionSet decodesTo CMS.Object.Color -> SelectionSet (List (Maybe decodesTo)) RootQuery
colors fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeColorWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.ColorOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "colors" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias LocationsOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.LocationWhereInput
    , orderBy : OptionalArgument CMS.Enum.LocationOrderByInput.LocationOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
locations : (LocationsOptionalArguments -> LocationsOptionalArguments) -> SelectionSet decodesTo CMS.Object.Location -> SelectionSet (List (Maybe decodesTo)) RootQuery
locations fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeLocationWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.LocationOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "locations" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias PagesOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.PageWhereInput
    , orderBy : OptionalArgument CMS.Enum.PageOrderByInput.PageOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
pages : (PagesOptionalArguments -> PagesOptionalArguments) -> SelectionSet decodesTo CMS.Object.Page -> SelectionSet (List (Maybe decodesTo)) RootQuery
pages fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodePageWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.PageOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pages" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias CallToActionsOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.CallToActionWhereInput
    , orderBy : OptionalArgument CMS.Enum.CallToActionOrderByInput.CallToActionOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
callToActions : (CallToActionsOptionalArguments -> CallToActionsOptionalArguments) -> SelectionSet decodesTo CMS.Object.CallToAction -> SelectionSet (List (Maybe decodesTo)) RootQuery
callToActions fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeCallToActionWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.CallToActionOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "callToActions" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias FaqsOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.FaqWhereInput
    , orderBy : OptionalArgument CMS.Enum.FaqOrderByInput.FaqOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
faqs : (FaqsOptionalArguments -> FaqsOptionalArguments) -> SelectionSet decodesTo CMS.Object.Faq -> SelectionSet (List (Maybe decodesTo)) RootQuery
faqs fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeFaqWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.FaqOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "faqs" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias ExplanationBlocksOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.ExplanationBlockWhereInput
    , orderBy : OptionalArgument CMS.Enum.ExplanationBlockOrderByInput.ExplanationBlockOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
explanationBlocks : (ExplanationBlocksOptionalArguments -> ExplanationBlocksOptionalArguments) -> SelectionSet decodesTo CMS.Object.ExplanationBlock -> SelectionSet (List (Maybe decodesTo)) RootQuery
explanationBlocks fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeExplanationBlockWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.ExplanationBlockOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "explanationBlocks" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias AssetRequiredArguments =
    { where_ : CMS.InputObject.AssetWhereUniqueInput }


asset : AssetRequiredArguments -> SelectionSet decodesTo CMS.Object.Asset -> SelectionSet (Maybe decodesTo) RootQuery
asset requiredArgs object_ =
    Object.selectionForCompositeField "asset" [ Argument.required "where" requiredArgs.where_ CMS.InputObject.encodeAssetWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias ColorRequiredArguments =
    { where_ : CMS.InputObject.ColorWhereUniqueInput }


color : ColorRequiredArguments -> SelectionSet decodesTo CMS.Object.Color -> SelectionSet (Maybe decodesTo) RootQuery
color requiredArgs object_ =
    Object.selectionForCompositeField "color" [ Argument.required "where" requiredArgs.where_ CMS.InputObject.encodeColorWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias LocationRequiredArguments =
    { where_ : CMS.InputObject.LocationWhereUniqueInput }


location : LocationRequiredArguments -> SelectionSet decodesTo CMS.Object.Location -> SelectionSet (Maybe decodesTo) RootQuery
location requiredArgs object_ =
    Object.selectionForCompositeField "location" [ Argument.required "where" requiredArgs.where_ CMS.InputObject.encodeLocationWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias PageRequiredArguments =
    { where_ : CMS.InputObject.PageWhereUniqueInput }


page : PageRequiredArguments -> SelectionSet decodesTo CMS.Object.Page -> SelectionSet (Maybe decodesTo) RootQuery
page requiredArgs object_ =
    Object.selectionForCompositeField "page" [ Argument.required "where" requiredArgs.where_ CMS.InputObject.encodePageWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias CallToActionRequiredArguments =
    { where_ : CMS.InputObject.CallToActionWhereUniqueInput }


callToAction : CallToActionRequiredArguments -> SelectionSet decodesTo CMS.Object.CallToAction -> SelectionSet (Maybe decodesTo) RootQuery
callToAction requiredArgs object_ =
    Object.selectionForCompositeField "callToAction" [ Argument.required "where" requiredArgs.where_ CMS.InputObject.encodeCallToActionWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias FaqRequiredArguments =
    { where_ : CMS.InputObject.FaqWhereUniqueInput }


faq : FaqRequiredArguments -> SelectionSet decodesTo CMS.Object.Faq -> SelectionSet (Maybe decodesTo) RootQuery
faq requiredArgs object_ =
    Object.selectionForCompositeField "faq" [ Argument.required "where" requiredArgs.where_ CMS.InputObject.encodeFaqWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias ExplanationBlockRequiredArguments =
    { where_ : CMS.InputObject.ExplanationBlockWhereUniqueInput }


explanationBlock : ExplanationBlockRequiredArguments -> SelectionSet decodesTo CMS.Object.ExplanationBlock -> SelectionSet (Maybe decodesTo) RootQuery
explanationBlock requiredArgs object_ =
    Object.selectionForCompositeField "explanationBlock" [ Argument.required "where" requiredArgs.where_ CMS.InputObject.encodeExplanationBlockWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias AssetsConnectionOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.AssetWhereInput
    , orderBy : OptionalArgument CMS.Enum.AssetOrderByInput.AssetOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
assetsConnection : (AssetsConnectionOptionalArguments -> AssetsConnectionOptionalArguments) -> SelectionSet decodesTo CMS.Object.AssetConnection -> SelectionSet decodesTo RootQuery
assetsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeAssetWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.AssetOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "assetsConnection" optionalArgs object_ identity


type alias ColorsConnectionOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.ColorWhereInput
    , orderBy : OptionalArgument CMS.Enum.ColorOrderByInput.ColorOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
colorsConnection : (ColorsConnectionOptionalArguments -> ColorsConnectionOptionalArguments) -> SelectionSet decodesTo CMS.Object.ColorConnection -> SelectionSet decodesTo RootQuery
colorsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeColorWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.ColorOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "colorsConnection" optionalArgs object_ identity


type alias LocationsConnectionOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.LocationWhereInput
    , orderBy : OptionalArgument CMS.Enum.LocationOrderByInput.LocationOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
locationsConnection : (LocationsConnectionOptionalArguments -> LocationsConnectionOptionalArguments) -> SelectionSet decodesTo CMS.Object.LocationConnection -> SelectionSet decodesTo RootQuery
locationsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeLocationWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.LocationOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "locationsConnection" optionalArgs object_ identity


type alias PagesConnectionOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.PageWhereInput
    , orderBy : OptionalArgument CMS.Enum.PageOrderByInput.PageOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
pagesConnection : (PagesConnectionOptionalArguments -> PagesConnectionOptionalArguments) -> SelectionSet decodesTo CMS.Object.PageConnection -> SelectionSet decodesTo RootQuery
pagesConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodePageWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.PageOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pagesConnection" optionalArgs object_ identity


type alias CallToActionsConnectionOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.CallToActionWhereInput
    , orderBy : OptionalArgument CMS.Enum.CallToActionOrderByInput.CallToActionOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
callToActionsConnection : (CallToActionsConnectionOptionalArguments -> CallToActionsConnectionOptionalArguments) -> SelectionSet decodesTo CMS.Object.CallToActionConnection -> SelectionSet decodesTo RootQuery
callToActionsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeCallToActionWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.CallToActionOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "callToActionsConnection" optionalArgs object_ identity


type alias FaqsConnectionOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.FaqWhereInput
    , orderBy : OptionalArgument CMS.Enum.FaqOrderByInput.FaqOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
faqsConnection : (FaqsConnectionOptionalArguments -> FaqsConnectionOptionalArguments) -> SelectionSet decodesTo CMS.Object.FaqConnection -> SelectionSet decodesTo RootQuery
faqsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeFaqWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.FaqOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "faqsConnection" optionalArgs object_ identity


type alias ExplanationBlocksConnectionOptionalArguments =
    { where_ : OptionalArgument CMS.InputObject.ExplanationBlockWhereInput
    , orderBy : OptionalArgument CMS.Enum.ExplanationBlockOrderByInput.ExplanationBlockOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
explanationBlocksConnection : (ExplanationBlocksConnectionOptionalArguments -> ExplanationBlocksConnectionOptionalArguments) -> SelectionSet decodesTo CMS.Object.ExplanationBlockConnection -> SelectionSet decodesTo RootQuery
explanationBlocksConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ CMS.InputObject.encodeExplanationBlockWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum CMS.Enum.ExplanationBlockOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "explanationBlocksConnection" optionalArgs object_ identity


type alias NodeRequiredArguments =
    { id : CMS.Scalar.Id }


{-| Fetches an object given its ID

  - id - The ID of an object

-}
node : NodeRequiredArguments -> SelectionSet decodesTo CMS.Interface.Node -> SelectionSet (Maybe decodesTo) RootQuery
node requiredArgs object_ =
    Object.selectionForCompositeField "node" [ Argument.required "id" requiredArgs.id (\(CMS.Scalar.Id raw) -> Encode.string raw) ] object_ (identity >> Decode.nullable)
